# -*- coding: utf-8 -*-
"""
Created on Sat May 23 01:48:08 2020

@author:
"""
from __future__ import print_function

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

def HITDetector(rayDirection):
    """Function to check if the generated Photons hit the detector
       Here a and be give the detactor geometry.
       They discribe the surface of the detector
      Returns a boolean of weather the photo hits or misses the detector.
    """

    x=rayDirection[0]
    y=rayDirection[1]
    z=rayDirection[2]
    Dic_Dim=20 #detectoer dimentions
    
    return abs(y)<=Dic_Dim and abs(z)<=Dic_Dim

def LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6):
    
    ndotu = planeNormal.dot(rayDirection)
    if abs(ndotu) < epsilon:
        raise RuntimeError("no intersection or line is within plane")
       
    w = rayPoint - planePoint
    si = -planeNormal.dot(w) / ndotu
    Psi = w + si * rayDirection + planePoint
    return Psi
def Propagate(x,y,z):
    """ 
     This checks if the for the given photon with direction x,y,x
     does it hit the detector
     
     returns Psi(position where the photon hit" and a boolean true 
     if photon hit the detector surface
     returns false if not.
    
    """
    #Define Plane At The Detector Position
    planeNormal = np.array([-1, 0, 0])
    planePoint = np.array([25, 0, 0]) #point of where the detector is
    #Define ray or vector that describes the direction of Photons momentun
    rayDirection = np.array([x,y , z])
    
    rayPoint = np.array([0, 0, 0]) #Any point along the ray
    if rayDirection[0]>0:
        #check if photon is going towards the detector
        Psi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)
        #print ("intersection at", Psi,HITDetector(rayDirection))
        if(HITDetector(Psi)):
            #check if the photon hits the detecter
            #print("Hit Detector At",Psi)
            
            return [True,Psi]
            

    return [False,[0,0,0]]

def generate_correct(N):
    #Here random directions of the momentum directions of N photons is generated
    theta = np.arccos( 1 - 2*np.random.uniform(size=N) )
    phi = 2*np.pi * np.random.uniform(size=N)

    x = np.sin(theta)*np.cos(phi)
    y = np.sin(theta)*np.sin(phi)
    z = np.cos(theta)

    return (x,y,z)

def detector(N):
    """
     returns the number of photons that hit the detector
     and draws the surface angle generated by the photon directions
    
    """
    x1=[]
    y1=[]
    z1=[]
    x,y,z = generate_correct(N)
    count=0
    for i in range(len(x)):
        r=38
        if(Propagate(r*x[i],r*y[i],r*z[i])[0]):
            
            count+=1
            x1.append(r*x[i])
            y1.append(r*y[i])
            z1.append(r*z[i])
    go.Figure(data=[go.Scatter3d(x=x1, y=y1, z=z1, marker={'size': 3}, mode='markers')]).show()
    
    return count
N=2000
count=detector(N)
print("Number of photons that hit the detector is",count)
print("%of photons that hit the detector is",count/N*100,"%")
